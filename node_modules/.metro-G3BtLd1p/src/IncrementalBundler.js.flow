/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 * @format
 */

'use strict';

import type {DeltaResult, Graph, Module} from './DeltaBundler';
import type {
  Dependencies,
  Options as DeltaBundlerOptions,
  TransformInputOptions,
} from './DeltaBundler/types.flow';
import type {GraphId} from './lib/getGraphId';
import type {ConfigT} from 'metro-config/src/configTypes.flow';

const Bundler = require('./Bundler');
const DeltaBundler = require('./DeltaBundler');
const ResourceNotFoundError = require('./IncrementalBundler/ResourceNotFoundError');
const getGraphId = require('./lib/getGraphId');
const getPrependedScripts = require('./lib/getPrependedScripts');
const transformHelpers = require('./lib/transformHelpers');
const crypto = require('crypto');
const fs = require('fs');
const path = require('path');

export opaque type RevisionId: string = string;

export type OutputGraph = Graph<>;

type OtherOptions = {|
  +onProgress: $PropertyType<DeltaBundlerOptions<>, 'onProgress'>,
  +shallow: boolean,
|};

export type GraphRevision = {|
  // Identifies the last computed revision.
  +id: RevisionId,
  +date: Date,
  +graphId: GraphId,
  +graph: OutputGraph,
  +prepend: $ReadOnlyArray<Module<>>,
|};

export type IncrementalBundlerOptions = $ReadOnly<{|
  hasReducedPerformance?: boolean,
  watch?: boolean,
|}>;

function createRevisionId(): RevisionId {
  return crypto.randomBytes(8).toString('hex');
}

function revisionIdFromString(str: string): RevisionId {
  return str;
}

class IncrementalBundler {
  _config: ConfigT;
  _bundler: Bundler;
  _deltaBundler: DeltaBundler<>;
  _revisionsById: Map<RevisionId, Promise<GraphRevision>> = new Map();
  _revisionsByGraphId: Map<GraphId, Promise<GraphRevision>> = new Map();

  static revisionIdFromString: (str: string) => RevisionId =
    revisionIdFromString;

  constructor(config: ConfigT, options?: IncrementalBundlerOptions) {
    this._config = config;
    this._bundler = new Bundler(config, options);
    this._deltaBundler = new DeltaBundler(this._bundler);
  }

  end(): void {
    this._deltaBundler.end();
    this._bundler.end();
  }

  getBundler(): Bundler {
    return this._bundler;
  }

  getDeltaBundler(): DeltaBundler<> {
    return this._deltaBundler;
  }

  getRevision(revisionId: RevisionId): ?Promise<GraphRevision> {
    return this._revisionsById.get(revisionId);
  }

  getRevisionByGraphId(graphId: GraphId): ?Promise<GraphRevision> {
    return this._revisionsByGraphId.get(graphId);
  }

  async buildGraphForEntries(
    entryFiles: $ReadOnlyArray<string>,
    transformOptions: TransformInputOptions,
    otherOptions?: OtherOptions = {
      onProgress: null,
      shallow: false,
    },
  ): Promise<OutputGraph> {
    const absoluteEntryFiles = await this._getAbsoluteEntryFiles(entryFiles);

    const graph = await this._deltaBundler.buildGraph(absoluteEntryFiles, {
      resolve: await transformHelpers.getResolveDependencyFn(
        this._bundler,
        transformOptions.platform,
      ),
      transform: await transformHelpers.getTransformFn(
        absoluteEntryFiles,
        this._bundler,
        this._deltaBundler,
        this._config,
        transformOptions,
      ),
      transformOptions,
      onProgress: otherOptions.onProgress,
      experimentalImportBundleSupport:
        this._config.transformer.experimentalImportBundleSupport,
      shallow: otherOptions.shallow,
    });

    this._config.serializer.experimentalSerializerHook(graph, {
      added: graph.dependencies,
      modified: new Map(),
      deleted: new Set(),
      reset: true,
    });

    return graph;
  }

  async getDependencies(
    entryFiles: $ReadOnlyArray<string>,
    transformOptions: TransformInputOptions,
    otherOptions?: OtherOptions = {
      onProgress: null,
      shallow: false,
    },
  ): Promise<Dependencies<>> {
    const absoluteEntryFiles = await this._getAbsoluteEntryFiles(entryFiles);

    const dependencies = await this._deltaBundler.getDependencies(
      absoluteEntryFiles,
      {
        resolve: await transformHelpers.getResolveDependencyFn(
          this._bundler,
          transformOptions.platform,
        ),
        transform: await transformHelpers.getTransformFn(
          absoluteEntryFiles,
          this._bundler,
          this._deltaBundler,
          this._config,
          transformOptions,
        ),
        transformOptions,
        onProgress: otherOptions.onProgress,
        experimentalImportBundleSupport:
          this._config.transformer.experimentalImportBundleSupport,
        shallow: otherOptions.shallow,
      },
    );

    return dependencies;
  }

  async buildGraph(
    entryFile: string,
    transformOptions: TransformInputOptions,
    otherOptions?: OtherOptions = {
      onProgress: null,
      shallow: false,
    },
  ): Promise<{|+graph: OutputGraph, +prepend: $ReadOnlyArray<Module<>>|}> {
    const graph = await this.buildGraphForEntries(
      [entryFile],
      transformOptions,
      otherOptions,
    );

    const {type: _